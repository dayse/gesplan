/* Generated By:JavaCC: Do not edit this line. XflParser.java */
package xfuzzy.lang;

import java.io.*;
import java.util.Vector;

/**
 * Parser del lenguaje XFL3
 * 
 * @author Francisco José Moreno Velo
 *
 */
public class XflParser implements XflParserConstants {

        //----------------------------------------------------------------------------//
        //                            MIEMBROS PRIVADOS                               //
        //----------------------------------------------------------------------------//

        /**
	 * Salto de línea
	 */
        private String eol = System.getProperty("line.separator", "\u005cn");

        /**
	 * Sistema que se está analizando
	 */
        private Specification spec;

        /**
	 * Conjunto de paquetes disponibles
	 */
        private XflPackageBank pkgbank;

        /**
	 * Contador de errores
	 */
        private int error;

        /**
	 * Contador de warnings
	 */
        private int warning;

        /**
	 * Mensaje de error
	 */
        private String errorMsg;

        /**
	 * Flag para detectar si se ha definido el módulo "crisp"
	 */
        private boolean crispDefined;

        /**
	 * Flag para detectar si se ha definido el módulo "system"
	 */
        private boolean systemDefined;

        /**
	 * Flag para detectar si se reconoce algo después de salir de
	 * la especificación
	 */
        private boolean end;

        //----------------------------------------------------------------------------//
        //                                CONSTRUCTOR                                 //
        //----------------------------------------------------------------------------//

        public XflParser () {
                this.error = 0;
                this.warning = 0;
                this.errorMsg = "";
                this.crispDefined = false;
                this.systemDefined = false;
        }

        //----------------------------------------------------------------------------//
        //                             MÉTODOS PÚBLICOS                               //
        //----------------------------------------------------------------------------//

        /**
	 * Analiza la sintaxis de un fichero de especificacion de un
	 * sistema difuso
	 */
        public Specification parse(String filename) {
                this.error = 0;
                this.warning = 0;
                this.errorMsg = "";
                this.crispDefined = false;
                this.systemDefined = false;
                this.pkgbank = new XflPackageBank();

                File file = new File(filename);
                this.spec = new Specification(file);

                InputStream stream;
                try { stream = new FileInputStream(filename); }
                catch (Exception e) {
                        this.errorMsg += "Can't open file"+filename+eol;
                        this.error ++;
                        return null;
                }

                jj_input_stream = new SimpleCharStream(stream, 1, 1);
                token_source = new XflParserTokenManager(jj_input_stream);
                ReInit(stream);
                try { system(); }
                catch (ParseException e) {
                        this.errorMsg += "Fatal error loading "+filename+eol;
                        this.error ++;
                        return null;
                }
                catch (TokenMgrError e) {
                        this.errorMsg += "Fatal error loading "+filename+eol;
                        this.error ++;
                        return null;
                }

                try { stream.close(); } catch (IOException e) {}

                if(this.error>0) return null;
                return spec;
        }

        /**
	 * Analiza la sintaxis de un flujo de entrada que contenga la
	 * especificación de un sistema difuso
	 */
        public Specification parse(InputStream stream, String name) {
                this.error = 0;
                this.warning = 0;
                this.errorMsg = "";
                this.crispDefined = false;
                this.systemDefined = false;
                this.pkgbank = new XflPackageBank();

                this.spec = new Specification(name);

                ReInit(stream);
                try { system(); }
                catch (ParseException e) {
                        this.errorMsg += "Fatal error loading stream"+eol;
                        this.error ++;
                        return null;
                }
                catch (TokenMgrError e) {
                        this.errorMsg += "Fatal error loading stream"+eol;
                        this.error ++;
                        return null;
                }

                try { stream.close(); } catch (IOException e) {}

                if(this.error>0) return null;
                return spec;
        }

        /**
	 * Obtiene el mensaje de error del análisis sintáctico	
	 */
        public String resume() {
                String msg = this.errorMsg + this.error;
                if(this.error == 1) msg += " error"; else msg += " errors";
                if(this.warning == 0) msg += ".";
                else if(this.warning == 1) msg += " and "+this.warning+" warning.";
                else msg += " and "+this.warning+" warnings.";
                return msg;
        }

        /**
	 * Ejecución externa
	 */
        public static void main(String args[]) throws Exception {
                if(args.length != 1 && args.length != 3) return;
                XflParser parser = new XflParser();
                Specification spec = parser.parse(args[0]);
                if(spec == null) System.out.println(parser.resume());
                else System.out.println(spec.toXfl());
        }

        //----------------------------------------------------------------------------//
        //                             MÉTODOS PÚBLICOS                               //
        //----------------------------------------------------------------------------//

        /**
	 * Crea un nuevo conjunto de operadores
	 */
        private Operatorset newOperatorset(Token tid) {
                if(spec.searchOperatorset(tid.image)!=null) exception(tid, 9);
                Operatorset newop = new Operatorset(tid.image);
                spec.addOperatorset(newop);
                return newop;
        }

        /**
	 * Crea un nuevo operador de un conjunto de operadores
	 */
        private void newOperator(Operatorset op,Token top, Token tid, double param[]) {
                int kindop = -1;
                int kindfz = -1;
                if(top.image.equals("and"))
                { kindop = FuzzyOperator.AND; kindfz = XflPackage.BINARY; }
                if(top.image.equals("or"))
                { kindop = FuzzyOperator.OR; kindfz = XflPackage.BINARY; }
                if(top.image.equals("also"))
                { kindop = FuzzyOperator.ALSO; kindfz = XflPackage.BINARY; }
                if(top.image.equals("imp") || top.image.equals("implication"))
                { kindop = FuzzyOperator.IMP; kindfz = XflPackage.BINARY; }
                if(top.image.equals("not"))
                { kindop = FuzzyOperator.NOT; kindfz = XflPackage.UNARY; }
                if(top.image.equals("very") || top.image.equals("strongly"))
                { kindop = FuzzyOperator.VERY; kindfz = XflPackage.UNARY; }
                if(top.image.equals("moreorless"))
                { kindop = FuzzyOperator.MOREORLESS; kindfz = XflPackage.UNARY; }
                if(top.image.equals("slightly"))
                { kindop = FuzzyOperator.SLIGHTLY; kindfz = XflPackage.UNARY; }
                if(top.image.equals("defuzzification") || top.image.equals("defuz"))
                { kindop = FuzzyOperator.DEFUZMETHOD; kindfz = XflPackage.DEFUZ; }
                if(kindop == -1) { exception(top,5); return; }

                FuzzyOperator operator = null;
                int index = tid.image.indexOf('.');
                String pkgname = tid.image.substring(0,index);
                String opname = tid.image.substring(index+1);
                if(!pkgbank.contains(pkgname,opname,kindfz)) { exception(tid,4); return; }
                operator = (FuzzyOperator) pkgbank.instantiate(pkgname,opname, kindfz);
                if(operator==null)
                try{ operator.set(param); } catch(Exception e) { exception(tid,34); return; }
                op.set(operator, kindop);
        }

        /**
	 * Crea una lista de parámetros
	 */
        private double[] newParameters(Token tn[],int counter) {
                double param[] = new double[counter];
                for(int i=0; i<counter; i++) param[i] = Double.parseDouble(tn[i].image);
                return param;
        }

        /**
	 * Crea un tipo de variable difusa
	 */
        private Type newType(Token tid, Token tp, Universe u) {
                Type newtype = null;
                if(spec.searchType(tid.image)!=null) { exception(tid, 11); return null; }
                if(u != null) newtype = new Type(tid.image,u);
                else if(tp != null) {
                        Type parent=spec.searchType(tp.image);
                        if(parent == null) exception(tp,12);
                        else newtype = new Type(tid.image,parent);
                }
                if(newtype==null) newtype = new Type(tid.image);
                spec.addType(newtype);
                return newtype;
        }

        /**
	 * Crea un nuevo universo de discurso
	 */
        private Universe newUniverse(Token tmin, Token tmax, Token tcard) {
                double min = Double.valueOf(tmin.image).doubleValue();
                double max = Double.valueOf(tmax.image).doubleValue();
                if(tcard == null)
                        try { return new Universe(min,max); }
                catch (XflException e) { exception(tmin, e); return null; }

                try {
                        int card = Integer.parseInt(tcard.image);
                        return new Universe(min,max,card);
                }
                catch (XflException e) { exception(tmin, e); return null; }
                catch (NumberFormatException e) { exception(tmin, 2); return null; }
        }

        /**
	 * Crea una nueva familia de funciones de pertenencia
	 */
        private void newFamily(Type type, Token tfam, Token tid, double param[]) {
                if(type == null) return;
                Family fam = null;
                int index = tid.image.indexOf('.');
                String pkgname = tid.image.substring(0,index);
                String famname = tid.image.substring(index+1);
                if(!pkgbank.contains(pkgname,famname,XflPackage.FAMILY)) {
                        exception(tid,36);
                        return;
                }
                fam = (Family) pkgbank.instantiate(pkgname,famname, XflPackage.FAMILY);
                if(fam==null) { exception(tid,36); return; }

                try {
                        fam.set(tfam.image, type);
                        fam.set(param);
                        type.addFamily(fam);
                }
                catch (XflException e) { exception(tfam, e); }
        }

        /**
	 * Crea una nueva función de pertenencia de un tipo
	 */
        private void newMemFunc(Type type, Token tmf, Token tid, double param[]) {
                if(type == null) return;
                ParamMemFunc mf = null;
                int index = tid.image.indexOf('.');
                String pkgname = tid.image.substring(0,index);
                String mfname = tid.image.substring(index+1);
                if(!pkgbank.contains(pkgname,mfname,XflPackage.MFUNC)) {
                        exception(tid,7);
                        return;
                }
                mf = (ParamMemFunc) pkgbank.instantiate(pkgname,mfname, XflPackage.MFUNC);
                if(mf==null) { exception(tid,7); return; }

                try {
                        mf.set(tmf.image, type.getUniverse());
                        mf.set(param);
                        type.add(mf);
                }
                catch (XflException e) { exception(tmf, e); }
        }

        /**
	 * Crea una nueva funcion de pertenencia familiar
	 */
        private void newFamiliarMemFunc(Type type, Token tmf, Token tid, int index) {
                if(type == null) return;
                Family fam = type.searchFamily(tid.image);
                if(fam==null) { exception(tid,37); return; }
                try {
                        type.add(new FamiliarMemFunc(tmf.image,fam,index));
                }
                catch (XflException e) { exception(tmf, e); }
        }

        /**
	 * Crea un nueva base de reglas
	 */
        private Rulebase newRulebase(Token tmod) {
                CrispBlockSet cbs = spec.getCrispBlockSet();
                if(cbs.search(tmod.image)!=null) { exception(tmod,41); return null; }
                if(spec.searchRulebase(tmod.image)!=null) {exception(tmod,13); return null; }
                Rulebase newmod = new Rulebase(tmod.image);
                spec.addRulebase(newmod);
                return newmod;
        }

        /**
	 * Crea una nueva variable de una base de reglas
	 */
        private void newVariable(Rulebase mod,Token ttype, Token tvar, boolean input) {
                if(mod == null) return;
                Type type = spec.searchType(ttype.image);
                if(type == null) { exception(ttype,12); return; }
                if(mod.searchVariable(tvar.image) != null ) { exception(tvar,15); return; }
                if(input) {
                        Variable inputvar = new Variable(tvar.image,type,Variable.INPUT);
                        mod.addInputVariable(inputvar);
                }
                else {
                        Variable outputvar = new Variable(tvar.image,type,mod);
                        mod.addOutputVariable(outputvar);
                }
        }

        /**
	 * Asigna a una base de reglas su conjunto de operadores
	 */
        private void newUsingOp(Rulebase mod, Token top) {
                if(mod == null) return;

                if(top == null) {
                        Operatorset op = spec.searchOperatorset("_default_");
                        if(op == null) { op = new Operatorset(); spec.addOperatorset(op); }
                        mod.setOperatorset(op);
                        return;
                }

                Operatorset op = spec.searchOperatorset(top.image);
                if(op==null) exception(top,10);
                else mod.setOperatorset(op);
        }

        /**
	 * Crea una nueva regla de una base de reglas
	 */
        private Rule newRule(Relation rel, Rulebase mod, Token tdg) {
                Rule rule;
                if(tdg == null) rule = new Rule(rel);
                else {
                        double degree = Double.parseDouble(tdg.image);
                        rule = new Rule(rel,degree);
                }
                mod.addRule(rule);
                return rule;
        }

        /**
	 * Crea una nueva proposición para el antecedente de una regla
	 */
        private Relation newProposition(Token tvar,Token tmf,Rulebase mod,int code) {
                Variable var = mod.searchVariable(tvar.image);
                if(var == null) { exception(tvar, 16); return null; }

                LinguisticLabel mf = var.search(tmf.image);
                if(mf == null) { exception(tvar, 6); return null; }

                switch (code) {
                case 0: return Relation.create(Relation.IS,null,null,var,mf,mod);
                case 1: return Relation.create(Relation.ISNOT,null,null,var,mf,mod);
                case 2: return Relation.create(Relation.GR_EQ,null,null,var,mf,mod);
                case 3: return Relation.create(Relation.SM_EQ,null,null,var,mf,mod);
                case 4: return Relation.create(Relation.GREATER,null,null,var,mf,mod);
                case 5: return Relation.create(Relation.SMALLER,null,null,var,mf,mod);
                case 6: return Relation.create(Relation.APP_EQ,null,null,var,mf,mod);
                case 7: return Relation.create(Relation.VERY_EQ,null,null,var,mf,mod);
                case 8: return Relation.create(Relation.SL_EQ,null,null,var,mf,mod);
                default: return null;
                }
        }

        /**
	 * Crea una nueva conclusión para el consecuente de una regla
	 */
        private void newConclusion(Token tvar, Token tmf, Rulebase mod, Rule rule) {
                if(rule == null) return;
                Variable output = mod.searchVariable(tvar.image);
                if(output==null) { exception(tvar,16); return; }
                LinguisticLabel mf = output.search(tmf.image);
                if(mf==null) { exception(tmf,6); return; }
                rule.add(new Conclusion(output,mf,mod));
        }

        /**
	 * Crea el conjunto de bloques no difusos
	 */
        private void newCrispBlockSet(Token t) {
                if(crispDefined) { exception(t,39); return; }
                crispDefined = true;
        }

        /**
	 * Crea un nuevo bloque de un conjunto de bloques no difusos
	 */
        private void newCrispBlock(Token tblock, Token tid, double param[]) {
                CrispBlockSet cbs = spec.getCrispBlockSet();
                if(cbs.search(tblock.image)!=null) { exception(tblock,41); return; }
                if(spec.searchRulebase(tblock.image)!=null) { exception(tblock,13); return; }

                CrispBlock block = null;
                int index = tid.image.indexOf('.');
                String pkgname = tid.image.substring(0,index);
                String blockname = tid.image.substring(index+1);
                if(!pkgbank.contains(pkgname,blockname,XflPackage.CRISP)) {
                        exception(tid,40);
                        return;
                }
                block = (CrispBlock) pkgbank.instantiate(pkgname,blockname, XflPackage.CRISP);
                if(block==null) { exception(tid,40); return; }
                try{ block.set(param); } catch(Exception e) { exception(tid,34); return; }
                block.setLabel(tblock.image);
                cbs.add(block);
        }

        /**
	 * Crea la descripción global del sistema difuso
	 */
        private void newSystemModule(Token t) {
                if(systemDefined) { exception(t,24); return; }
                systemDefined = true;
        }

        /**
	 * Crea una nueva variable global del sistema difuso
	 */
        private void newVariable(Token ttype, Token tid, boolean input) {
                Type type = spec.searchType(ttype.image);
                if(type == null) { exception(ttype,12); return; }
                if(spec.getSystemModule().searchVariable(tid.image) != null )
                { exception(tid,15); return; }
                if(input) {
                        Variable inputvar = new Variable(tid.image,type,Variable.INPUT);
                        spec.getSystemModule().addVariable(inputvar);
                }
                else {
                        Variable outputvar = new Variable(tid.image,type,Variable.OUTPUT);
                        spec.getSystemModule().addVariable(outputvar);
                }
        }

        /**
	 * Crea una nueva llamada a una base de reglas
	 */
        private void newCall(Token t, Vector iv, Vector ov) {
                Rulebase ref = spec.searchRulebase(t.image);
                CrispBlock block = spec.getCrispBlockSet().search(t.image);
                if(ref != null) {
                        if(ref.getInputs().length != iv.size()) { exception(t,21); return; }
                        if(ref.getOutputs().length != ov.size()) { exception(t,21); return; }
                } else if(block != null) {
                        if(block.inputs() != iv.size()) { exception(t,21); return; }
                        if(ov.size() != 1) { exception(t,21); return; }
                } else { exception(t,20); return; }

                Variable[] ivar = new Variable[iv.size()];
                Variable[] ovar = new Variable[ov.size()];
                for(int i=0; i<ivar.length; i++) {
                        String varname = (String) iv.elementAt(i);
                        ivar[i] = spec.getSystemModule().searchVariable( varname );
                        if(ivar[i] == null) { exception(t,22); return; }
                }
                for(int i=0; i<ovar.length; i++) {
                        String varname = (String) ov.elementAt(i);
                        ovar[i] = spec.getSystemModule().searchVariable( varname );
                        if(ovar[i] != null && !ovar[i].isOutput()) { exception(t,23); return; }
                        if(ovar[i] == null) {
                                ovar[i] = new Variable(varname,Variable.INNER);
                                spec.getSystemModule().addVariable(ovar[i]);
                        }
                }
                if(ref != null) spec.getSystemModule().addCall(ref,ivar,ovar);
                else spec.getSystemModule().addCall(block,ivar,ovar[0]);
        }

        /**
	 * Genera un error de sintaxis de XFL3
	 */
        private void exception(Token t, XflException e) {
                this.error ++;
                this.errorMsg += "Xfuzzy ["+this.error+"]. ";
                this.errorMsg += "Parse error at line "+t.beginLine+" : "+e+eol;
        }

        /**
	 * Genera un error de sintaxis de XFL3
	 */
        private void exception(Token t, int code) {
                this.error ++;
                this.errorMsg += "Xfuzzy ["+this.error+"]. ";
                this.errorMsg += "Parse error at line "+t.beginLine+" : ";
                this.errorMsg += XflException.getMessage(code)+eol;
        }

        /**
	 * Genera un error de sintaxis de XFL3
	 */
        private void exception(ParseException e) {
                Token t = e.currentToken.next;
                this.error ++;
                this.errorMsg += "Xfuzzy ["+this.error+"]. ";
                this.errorMsg += "Parse error at line "+t.beginLine+" : ";
                this.errorMsg += "Encountered \u005c""+t.image+"\u005c""+" while expecting ";

                int expected[] = new int[e.expectedTokenSequences.length];
                for(int i=0; i<expected.length; i++)
                        expected[i] = e.expectedTokenSequences[i][0];
                if(expected.length == 1) this.errorMsg += e.tokenImage[expected[0]]+"."+eol;
                else {
                        this.errorMsg += "one of :"+e.tokenImage[expected[0]];
                        for(int i=1; i<expected.length; i++)
                                this.errorMsg += ", "+e.tokenImage[expected[i]];
                        this.errorMsg += "."+eol;
                }
        }

        /**
	 * Genera un error léxico de XFL3
	 */
        private void exception(TokenMgrError e) {
                this.error ++;
                this.errorMsg += "Xfuzzy ["+this.error+"]. "+e.getMessage()+eol;
        }

  final public void system() throws ParseException {
        end = false;
    tryDefinitions();
  }

  final public void definition() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATORSET:
      tryOperatorset();
      break;
    case TYPE:
      tryType();
      break;
    case RULEBASE:
      tryRulebase();
      break;
    case CRISP:
      tryCrispBlockSet();
      break;
    case SYSTEM:
      trySystemModule();
      break;
    case 0:
      jj_consume_token(0);
           end = true;
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void tryOperatorset() throws ParseException {
    try {
      operatorset();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void operatorset() throws ParseException {
        Token tid;
        Operatorset newop;
    jj_consume_token(OPERATORSET);
    tid = jj_consume_token(ID);
         newop = newOperatorset(tid);
    jj_consume_token(38);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      tryOperator(newop);
    }
    jj_consume_token(39);
  }

  final public void tryOperator(Operatorset op) throws ParseException {
    try {
      operator(op);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void operator(Operatorset op) throws ParseException {
        Token top;
        Token tname;
        double param[];
    top = jj_consume_token(ID);
    tname = jj_consume_token(OPERATOR);
    param = tryParameters();
    jj_consume_token(40);
         newOperator(op,top,tname,param);
  }

  final public double[] tryParameters() throws ParseException {
        double param[];
    try {
      param = parameters();
                           {if (true) return param;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return new double[0];}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return new double[0];}
    }
    throw new Error("Missing return statement in function");
  }

  final public double[] parameters() throws ParseException {
        Token tn[] = new Token[25];
        int i=0;
    jj_consume_token(41);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      tn[i] = jj_consume_token(NUMBER);
                        i++;
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 42:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(42);
        tn[i] = jj_consume_token(NUMBER);
                                                    i++;
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
    jj_consume_token(43);
         {if (true) return newParameters(tn,i);}
    throw new Error("Missing return statement in function");
  }

  final public void tryType() throws ParseException {
    try {
      type();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void type() throws ParseException {
        Token tid;
        Token tp = null;
        Universe u = null;
        Type newtype;
    jj_consume_token(TYPE);
    tid = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
    case 44:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 44:
        u = universe();
        break;
      case EXTENDS:
        jj_consume_token(EXTENDS);
        tp = jj_consume_token(ID);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
         newtype = newType(tid,tp,u);
    jj_consume_token(38);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      tryTypeElement(newtype);
    }
    jj_consume_token(39);
  }

  final public Universe tryUniverse() throws ParseException {
        Universe u = null;
    try {
      u = universe();
                     {if (true) return u;}
    } catch (ParseException e) {
                            exception(e); skipto("]"); {if (true) return u;}
    } catch (TokenMgrError e) {
                           exception(e); skipto("]"); {if (true) return u;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Universe universe() throws ParseException {
        Token tmin;
        Token tmax;
        Token tcard=null;
    jj_consume_token(44);
    tmin = jj_consume_token(NUMBER);
    jj_consume_token(42);
    tmax = jj_consume_token(NUMBER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 40:
      jj_consume_token(40);
      tcard = jj_consume_token(NUMBER);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    jj_consume_token(45);
         {if (true) return newUniverse(tmin,tmax,tcard);}
    throw new Error("Missing return statement in function");
  }

  final public void tryTypeElement(Type type) throws ParseException {
    try {
      typeElement(type);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void typeElement(Type type) throws ParseException {
        Token tname;
    tname = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      family(type,tname);
      break;
    case ID:
    case OPERATOR:
      memfunc(type,tname);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void family(Type type, Token tname) throws ParseException {
        Token tfam;
        double param[];
    jj_consume_token(44);
    jj_consume_token(45);
    tfam = jj_consume_token(OPERATOR);
    param = tryParameters();
    jj_consume_token(40);
         newFamily(type,tname,tfam,param);
  }

  final public void memfunc(Type type, Token tname) throws ParseException {
        Token tmf;
        double param[];
        int index;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      tmf = jj_consume_token(OPERATOR);
      param = tryParameters();
      jj_consume_token(40);
         newMemFunc(type,tname,tmf,param);
      break;
    case ID:
      tmf = jj_consume_token(ID);
      index = tryIndex();
      jj_consume_token(40);
         newFamiliarMemFunc(type,tname,tmf,index);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public int tryIndex() throws ParseException {
        Token ti;
    jj_consume_token(44);
    ti = jj_consume_token(NUMBER);
    jj_consume_token(45);
         {if (true) return Integer.parseInt(ti.image);}
    throw new Error("Missing return statement in function");
  }

  final public void tryRulebase() throws ParseException {
    try {
      rulebase();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void rulebase() throws ParseException {
        Token tmod;
        Rulebase newmod;
    jj_consume_token(RULEBASE);
    tmod = jj_consume_token(ID);
                        newmod = newRulebase(tmod);
    tryVariables(newmod);
    tryUsingOp(newmod);
    label_4:
    while (true) {
      rule(newmod);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case 44:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(39);
  }

  final public void tryVariables(Rulebase mod) throws ParseException {
    try {
      variables(mod);
    } catch (ParseException e) {
                            exception(e); skipto(")");
    } catch (TokenMgrError e) {
                           exception(e); skipto(")");
    }
  }

  final public void variables(Rulebase mod) throws ParseException {
    jj_consume_token(41);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      variable(mod,true);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 42:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_5;
        }
        jj_consume_token(42);
        variable(mod, true);
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(46);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      variable(mod,false);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 42:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_6;
        }
        jj_consume_token(42);
        variable(mod, false);
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    jj_consume_token(43);
  }

  final public void variable(Rulebase mod, boolean input) throws ParseException {
        Token ttype;
        Token tvar;
    ttype = jj_consume_token(ID);
    tvar = jj_consume_token(ID);
         newVariable(mod,ttype,tvar,input);
  }

  final public void tryUsingOp(Rulebase mod) throws ParseException {
    try {
      usingop(mod);
    } catch (ParseException e) {
                            exception(e); skipto("{");
    } catch (TokenMgrError e) {
                           exception(e); skipto("{");
    }
  }

  final public void usingop(Rulebase mod) throws ParseException {
        Token top = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case USING:
      jj_consume_token(USING);
      top = jj_consume_token(ID);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    jj_consume_token(38);
         newUsingOp(mod,top);
  }

  final public void tryRule(Rulebase mod) throws ParseException {
    try {
      rule(mod);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void rule(Rulebase mod) throws ParseException {
        Rule rule;
        Token tdg = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
      jj_consume_token(44);
      tdg = jj_consume_token(NUMBER);
      jj_consume_token(45);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    jj_consume_token(IF);
    rule = tryAntecedent(mod, tdg);
    jj_consume_token(THEN);
    tryConclusions(mod, rule);
  }

  final public Rule tryAntecedent(Rulebase mod, Token tdg) throws ParseException {
        Rule rule;
    try {
      rule = antecedent(mod,tdg);
                                    {if (true) return rule;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return null;}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Rule antecedent(Rulebase mod, Token tdg) throws ParseException {
        Relation rel;
    jj_consume_token(41);
    rel = relation(mod);
    jj_consume_token(43);
         {if (true) return newRule(rel,mod,tdg);}
    throw new Error("Missing return statement in function");
  }

  final public Relation relation(Rulebase mod) throws ParseException {
        Relation rel;
        Relation lrel;
        Relation rrel;
    rel = unary(mod);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        jj_consume_token(AND);
        rrel = unary(mod);
         lrel = rel;
         rel = Relation.create(Relation.AND,lrel,rrel,null,null,mod);
        break;
      case OR:
        jj_consume_token(OR);
        rrel = unary(mod);
         lrel = rel;
         rel = Relation.create(Relation.OR,lrel,rrel,null,null,mod);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
         {if (true) return rel;}
    throw new Error("Missing return statement in function");
  }

  final public Relation unary(Rulebase mod) throws ParseException {
        Relation prop;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case 41:
      prop = proposition(mod);
         {if (true) return prop;}
      break;
    case NOT:
      jj_consume_token(NOT);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.NOT,prop,null,null,null,mod);}
      break;
    case VERY:
      jj_consume_token(VERY);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.VERY,prop,null,null,null,mod);}
      break;
    case MOREORLESS:
      jj_consume_token(MOREORLESS);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.MoL,prop,null,null,null,mod);}
      break;
    case SLIGHTLY:
      jj_consume_token(SLIGHTLY);
      prop = proposition(mod);
         {if (true) return Relation.create(Relation.SLIGHTLY,prop,null,null,null,mod);}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation proposition(Rulebase mod) throws ParseException {
        Relation prop;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      prop = simpleProposition(mod);
      break;
    case 41:
      prop = tryCompound(mod);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         {if (true) return prop;}
    throw new Error("Missing return statement in function");
  }

  final public Relation simpleProposition(Rulebase mod) throws ParseException {
        Token tvar;
        Token tmf;
        int code;
    tvar = jj_consume_token(ID);
    code = comparative();
    tmf = jj_consume_token(ID);
         {if (true) return newProposition(tvar,tmf,mod,code);}
    throw new Error("Missing return statement in function");
  }

  final public int comparative() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IS:
      jj_consume_token(IS);
          {if (true) return 0;}
      break;
    case ISNOT:
      jj_consume_token(ISNOT);
             {if (true) return 1;}
      break;
    case GREATEROREQUAL:
      jj_consume_token(GREATEROREQUAL);
                      {if (true) return 2;}
      break;
    case SMALLEROREQUAL:
      jj_consume_token(SMALLEROREQUAL);
                      {if (true) return 3;}
      break;
    case GREATER:
      jj_consume_token(GREATER);
               {if (true) return 4;}
      break;
    case SMALLER:
      jj_consume_token(SMALLER);
               {if (true) return 5;}
      break;
    case APPROXEQUAL:
      jj_consume_token(APPROXEQUAL);
                   {if (true) return 6;}
      break;
    case VERYEQUAL:
      jj_consume_token(VERYEQUAL);
                 {if (true) return 7;}
      break;
    case SLIGHTLYEQUAL:
      jj_consume_token(SLIGHTLYEQUAL);
                     {if (true) return 8;}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation tryCompound(Rulebase mod) throws ParseException {
        Relation prop;
    try {
      prop = compoundProposition(mod);
                                         {if (true) return prop;}
    } catch (ParseException e) {
                            exception(e); skipto(")"); {if (true) return null;}
    } catch (TokenMgrError e) {
                           exception(e); skipto(")"); {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public Relation compoundProposition(Rulebase mod) throws ParseException {
        Relation prop;
    jj_consume_token(41);
    prop = relation(mod);
    jj_consume_token(43);
         {if (true) return prop;}
    throw new Error("Missing return statement in function");
  }

  final public void tryConclusions(Rulebase mod, Rule rule) throws ParseException {
    try {
      conclusions(mod,rule);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void conclusions(Rulebase mod, Rule rule) throws ParseException {
        Token tvar;
        Token tmf;
    conclusion(mod,rule);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 42:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_8;
      }
      jj_consume_token(42);
      conclusion(mod,rule);
    }
    jj_consume_token(40);
  }

  final public void conclusion(Rulebase mod, Rule rule) throws ParseException {
        Token tvar;
        Token tmf;
    tvar = jj_consume_token(ID);
    jj_consume_token(ASIGN);
    tmf = jj_consume_token(ID);
         newConclusion(tvar,tmf,mod,rule);
  }

  final public void tryCrispBlockSet() throws ParseException {
    try {
      crispblockset();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void crispblockset() throws ParseException {
        Token t;
    t = jj_consume_token(CRISP);
         newCrispBlockSet(t);
    jj_consume_token(38);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      tryCrispBlock();
    }
    jj_consume_token(39);
  }

  final public void tryCrispBlock() throws ParseException {
    try {
      crispblock();
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void crispblock() throws ParseException {
        Token tid;
        Token tname;
        double param[];
    tid = jj_consume_token(ID);
    tname = jj_consume_token(OPERATOR);
    param = tryParameters();
    jj_consume_token(40);
         newCrispBlock(tid,tname,param);
  }

  final public void trySystemModule() throws ParseException {
    try {
      systemmod();
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void systemmod() throws ParseException {
        Token t;
    t = jj_consume_token(SYSTEM);
         newSystemModule(t);
    jj_consume_token(41);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      systemvar(true);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 42:
          ;
          break;
        default:
          jj_la1[24] = jj_gen;
          break label_10;
        }
        jj_consume_token(42);
        systemvar(true);
      }
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    jj_consume_token(46);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      systemvar(false);
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 42:
          ;
          break;
        default:
          jj_la1[26] = jj_gen;
          break label_11;
        }
        jj_consume_token(42);
        systemvar(false);
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(43);
    jj_consume_token(38);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_12;
      }
      tryCall();
    }
    jj_consume_token(39);
  }

  final public void systemvar(boolean input) throws ParseException {
        Token ttype;
        Token tid;
    ttype = jj_consume_token(ID);
    tid = jj_consume_token(ID);
         newVariable(ttype,tid,input);
  }

  final public void tryCall() throws ParseException {
    try {
      call();
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void call() throws ParseException {
        Token tmod;
        Token tvar;
        Vector iv = new Vector();
        Vector ov = new Vector();
    tmod = jj_consume_token(ID);
    jj_consume_token(41);
    tvar = jj_consume_token(ID);
                   iv.add(tvar.image);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 42:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_13;
      }
      jj_consume_token(42);
      tvar = jj_consume_token(ID);
                        iv.add(tvar.image);
    }
    jj_consume_token(46);
    tvar = jj_consume_token(ID);
                   ov.add(tvar.image);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 42:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_14;
      }
      jj_consume_token(42);
      tvar = jj_consume_token(ID);
                        ov.add(tvar.image);
    }
    jj_consume_token(43);
    jj_consume_token(40);
           newCall(tmod,iv,ov);
  }

  void tryDefinitions() throws ParseException {
 while(!end) {
  try { definition(); }
  catch (ParseException e) { exception(e); skipto("}"); }
  catch (TokenMgrError e) { exception(e); end = true; }
 }
  }

  void skipto(String st) throws ParseException {
 Token t;
 do { t = getNextToken();}
 while(t.kind != EOF && !t.image.equals(st));
  }

  /** Generated Token Manager. */
  public XflParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[31];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xcb01,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x1000,0x0,0x30000,0x30000,0x3c0000,0x0,0x7fc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x2,0x400,0x8,0x1000,0x1000,0x2,0x100,0x1006,0x6,0x1000,0x400,0x2,0x400,0x2,0x0,0x1000,0x0,0x0,0x202,0x202,0x0,0x400,0x2,0x400,0x2,0x400,0x2,0x2,0x400,0x400,};
   }

  /** Constructor with InputStream. */
  public XflParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XflParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XflParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public XflParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XflParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public XflParser(XflParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(XflParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 31; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[47];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 31; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 47; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
