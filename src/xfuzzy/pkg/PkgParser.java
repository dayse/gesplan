/* Generated By:JavaCC: Do not edit this line. PkgParser.java */
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
//		PARSER DE LOS PAQUETES DE FUNCIONES		//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

package xfuzzy.pkg;

import java.util.Vector;
import java.io.*;

/**
 * Parser de los paquetes de fiunciones
 *
 * @author Francisco José Moreno Velo
 */
public class PkgParser implements PkgParserConstants {

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //			CONSTANTES PRIVADAS			//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 private final int JAVABLOCK = 0;
 private final int DERIVBLOCK = 1;
 private final int ANSICBLOCK = 2;
 private final int CPPBLOCK = 3;

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //			MIEMBROS PRIVADOS			//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 private String eol = System.getProperty("line.separator", "\u005cn");
 private Vector path;
 private int error;
 private String errorMsg;
 private boolean end;

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //			  CONSTRUCTORES				//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 //-------------------------------------------------------------//
 // Constructor por defecto					//
 //-------------------------------------------------------------//

 public PkgParser() {
  this.path = new Vector();
  this.error = 0;
  this.errorMsg = "";
  defaultPath();
 }

 //-------------------------------------------------------------//
 // Constructor con una lista de directorios de busqueda	//
 //-------------------------------------------------------------//

 public PkgParser(File path[]) {
  this();
  for(int i=0; i<path.length; i++) this.path.addElement(path[i]);
 }

 //-------------------------------------------------------------//
 // Constructor con un directorio de busqueda			//
 //-------------------------------------------------------------//

 public PkgParser(File path) {
  this();
  this.path.addElement(path);
 }

 //-------------------------------------------------------------//
 // Constructor con un directorio de busqueda			//
 //-------------------------------------------------------------//

 public PkgParser(String dir) {
  this();
  File file = new File(dir);
  if(file.isDirectory()) this.path.addElement(path);
 }

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //			METODOS PUBLICOS			//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 //-------------------------------------------------------------//
 // Asigna el directorio de busqueda de paquetes		//
 //-------------------------------------------------------------//

 public void setPath(File path) {
  this.path = new Vector();
  this.path.addElement(path);
 }

 //-------------------------------------------------------------//
 // Asigna un conjunto de directorios de busqueda de paquetes	//
 //-------------------------------------------------------------//

 public void setPath(File path[]) {
  this.path = new Vector();
  for(int i=0; i<path.length; i++) this.path.addElement(path[i]);
 }

 //-------------------------------------------------------------//
 // Annade un directorio de busqueda de paquetes		//
 //-------------------------------------------------------------//

 public void addPath(File path) {
  this.path.addElement(path);
 }

 //-------------------------------------------------------------//
 // Analiza la sintaxis de un paquete de funciones		//
 // (a buscar entre los	directorios de busqueda asignados)	//
 //-------------------------------------------------------------//

 public PackageDefinition parse(String pkgname) {
  String filename = pkgname+".pkg";
  for(int i=0; i<path.size(); i++) {
   File dir = (File) this.path.elementAt(i);
   File file = new File(dir,filename);
   if(file.exists()) return parse(file);
  }
  return null;
 }

 //-------------------------------------------------------------//
 // Analiza la sintaxis de un paquete de funciones		//
 //-------------------------------------------------------------//

 public PackageDefinition parse(File file) {
  this.error = 0;
  this.errorMsg = "";
  PackageDefinition pkgdef = new PackageDefinition(file);
  String filename = file.getAbsolutePath();
  InputStream stream;
  try { stream = new FileInputStream(file); }
  catch (Exception e) {
   this.errorMsg += "Can't open file"+filename+eol;
   this.error++;
   return null;
  }

  jj_input_stream = new SimpleCharStream(stream, 1, 1);
  token_source = new PkgParserTokenManager(jj_input_stream);
  ReInit(stream);
  try { parsePackageDefinition(pkgdef); }
  catch (ParseException e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   return null;
  }
  catch (TokenMgrError e) {
   this.errorMsg += "Fatal error loading "+filename+eol;
   this.error ++;
   return null;
  }

  try { stream.close(); } catch (IOException e) {}

  if(this.error>0) return null;
  return pkgdef;
 }

 //-------------------------------------------------------------//
 // Ontiene los posibles mensajes de error del analisis		//
 //-------------------------------------------------------------//

 public String resume() {
  String msg = this.errorMsg + this.error;
  if(this.error == 1) msg += " error."; else msg += " errors.";
  return msg+eol;
 }

 //-------------------------------------------------------------//
 // Ejecucion externa						//
 //-------------------------------------------------------------//

 public static void main(String args[]) throws Exception {
  if(args.length != 1) return;
  PkgParser parser = new PkgParser();
  PackageDefinition pkgdef = parser.parse(new File(args[0]));
  if(pkgdef == null) System.out.println(parser.resume());
  else if(!pkgdef.compile()) System.out.println(pkgdef.resume());
 }

 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
 //			METODOS PRIVADOS			//
 //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

 //-------------------------------------------------------------//
 // Obtiene los directorios de busqueda por defecto		//
 //-------------------------------------------------------------//

 private void defaultPath() {
  File userdir = new File(System.getProperty("user.dir"));
  File pkgdir = new File( System.getProperty("xfuzzy.path")+"/pkg" );
  path.addElement(userdir);
  path.addElement(pkgdir);
 }

 //-------------------------------------------------------------//
 // Elimina los saltos de linea del comienzo y final de codigo	//
 //-------------------------------------------------------------//

 private String trim(String code) {
  String line,rest;
  int index;

  index = code.indexOf("\u005cn"); if(index == -1) return code;
  line = code.substring(0,index);
  if(line.trim().length() == 0) rest = code.substring(index+1);
  else rest = new String(code);
  index = rest.lastIndexOf("\u005cn"); if(index == -1) return rest;
  line = rest.substring(index);
  if(line.trim().length() == 0) rest = rest.substring(0,index);
  return rest;
 }

 //-------------------------------------------------------------//
 // Almacena la informacion de un error				//
 //-------------------------------------------------------------//

 private void exception(ParseException e) {
  Token t = e.currentToken.next;
  this.error ++;
  this.errorMsg += "PackageDefinition ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : ";
  this.errorMsg += "Encountered \u005c""+t.image+"\u005c""+" while expecting ";

  int expected[] = new int[e.expectedTokenSequences.length];
  for(int i=0; i<expected.length; i++)
   expected[i] = e.expectedTokenSequences[i][0];
  if(expected.length == 1) this.errorMsg += e.tokenImage[expected[0]]+"."+eol;
  else {
   this.errorMsg += "one of :"+e.tokenImage[expected[0]];
   for(int i=1; i<expected.length; i++)
    this.errorMsg += ", "+e.tokenImage[expected[i]];
   this.errorMsg += "."+eol;
  }
 }

 //-------------------------------------------------------------//
 // Almacena la informacion de un error				//
 //-------------------------------------------------------------//

 private void exception(TokenMgrError e) {
  this.error ++;
  this.errorMsg += "PackageDefinition ["+this.error+"]. "+e.getMessage()+eol;
 }

  final public void tryDefinition(PackageDefinition pkg) throws ParseException {
    try {
      definition(pkg);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void definition(PackageDefinition pkg) throws ParseException {
        Definition def;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BINARY:
      def = binarydef(pkg);
                         pkg.add(def,PackageDefinition.BINARY);
      break;
    case UNARY:
      def = unarydef(pkg);
                        pkg.add(def,PackageDefinition.UNARY);
      break;
    case MF:
      def = mfdef(pkg);
                        pkg.add(def,PackageDefinition.MFUNC);
      break;
    case DEFUZ:
      def = defuzdef(pkg);
                        pkg.add(def,PackageDefinition.DEFUZ);
      break;
    case FAMILY:
      def = familydef(pkg);
                         pkg.add(def,PackageDefinition.FAMILY);
      break;
    case CRISP:
      def = crispdef(pkg);
                        pkg.add(def,PackageDefinition.CRISP);
      break;
    case 0:
      jj_consume_token(0);
          end = true;
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public Definition binarydef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(BINARY);
    tid = jj_consume_token(ID);
         def = Definition.createBinaryDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      case UPDATE:
        tryUpdateBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
      case UPDATE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition unarydef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(UNARY);
    tid = jj_consume_token(ID);
         def = Definition.createUnaryDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      case UPDATE:
        tryUpdateBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
      case UPDATE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition defuzdef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(DEFUZ);
    tid = jj_consume_token(ID);
         def = Definition.createDefuzDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case UPDATE:
        tryUpdateBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      case DEFINED:
        tryDefineBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case DERIVATIVE:
        tryDerivativeBlock(def);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case DEFINED:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
      case UPDATE:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition mfdef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(MF);
    tid = jj_consume_token(ID);
         def = Definition.createMFDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case UPDATE:
        tryUpdateBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      case JAVA:
        tryMFJavaBlock(def);
        break;
      case ANSI_C:
        tryMFAnsiCBlock(def);
        break;
      case CPLUSPLUS:
        tryMFCppBlock(def);
        break;
      case DERIVATIVE:
        tryMFDerivativeBlock(def);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
      case UPDATE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition familydef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(FAMILY);
    tid = jj_consume_token(ID);
         def = Definition.createFamilyDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case MEMBERS:
        tryMembersBlock(def);
        break;
      case UPDATE:
        tryUpdateBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      case JAVA:
        tryMFJavaBlock(def);
        break;
      case ANSI_C:
        tryMFAnsiCBlock(def);
        break;
      case CPLUSPLUS:
        tryMFCppBlock(def);
        break;
      case DERIVATIVE:
        tryMFDerivativeBlock(def);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case DERIVATIVE:
      case REQUIRES:
      case SOURCE:
      case MEMBERS:
      case UPDATE:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public Definition crispdef(PackageDefinition pkg) throws ParseException {
        Definition def;
        Token tid;
    jj_consume_token(CRISP);
    tid = jj_consume_token(ID);
         def = Definition.createCrispDefinition(pkg.toString(), tid.image);
    jj_consume_token(36);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
        tryAliasBlock(def);
        break;
      case PARAM:
        tryParamBlock(def);
        break;
      case REQUIRES:
        tryRequiresBlock(def);
        break;
      case INPUTS:
        tryInputsBlock(def);
        break;
      case JAVA:
        tryJavaBlock(def);
        break;
      case ANSI_C:
        tryCBlock(def);
        break;
      case CPLUSPLUS:
        tryCppBlock(def);
        break;
      case SOURCE:
        tryOtherBlock(def);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALIAS:
      case PARAM:
      case JAVA:
      case ANSI_C:
      case CPLUSPLUS:
      case REQUIRES:
      case SOURCE:
      case INPUTS:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
    }
    jj_consume_token(37);
         {if (true) return def;}
    throw new Error("Missing return statement in function");
  }

  final public void tryAliasBlock(Definition def) throws ParseException {
    try {
      aliasblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void aliasblock(Definition def) throws ParseException {
        Vector vector = new Vector();
        Token tid;
    jj_consume_token(ALIAS);
    tid = jj_consume_token(ID);
                    vector.addElement( tid.image );
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 38:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_7;
      }
      jj_consume_token(38);
      tid = jj_consume_token(ID);
                   vector.addElement( tid.image );
    }
    jj_consume_token(39);
         def.setAlias(vector);
  }

  final public void tryParamBlock(Definition def) throws ParseException {
    try {
      paramblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void paramblock(Definition def) throws ParseException {
        Vector vector = new Vector();
    jj_consume_token(PARAM);
    paramdef(def,vector);
         def.setParameters(vector);
  }

  final public void paramdef(Definition def, Vector vector) throws ParseException {
        Token tid;
    tid = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 39:
      jj_consume_token(39);
          vector.addElement( tid.image );
      break;
    case 40:
      jj_consume_token(40);
      jj_consume_token(41);
      jj_consume_token(39);
                 def.setParamList( tid.image );
      break;
    case 38:
      jj_consume_token(38);
         vector.addElement( tid.image );
      paramdef(def,vector);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void tryRequiresBlock(Definition def) throws ParseException {
    try {
      requiresblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void requiresblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(REQUIRES);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.REQUIREMENTS,trim(code));
  }

  final public void tryUpdateBlock(Definition def) throws ParseException {
    try {
      updateblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void updateblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(UPDATE);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.UPDATE,trim(code));
  }

  final public void tryOtherBlock(Definition def) throws ParseException {
    try {
      otherblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void otherblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(SOURCE);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.SOURCE,trim(code));
  }

  final public void tryDefineBlock(Definition def) throws ParseException {
    try {
      defineblock(def);
    } catch (ParseException e) {
                            exception(e); skipto(";");
    } catch (TokenMgrError e) {
                           exception(e); skipto(";");
    }
  }

  final public void defineblock(Definition def) throws ParseException {
        Vector vector = new Vector();
        Token tid;
    jj_consume_token(DEFINED);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPERATOR:
      tid = jj_consume_token(OPERATOR);
      break;
    case ID:
      tid = jj_consume_token(ID);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                         vector.addElement( tid.image );
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 38:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_8;
      }
      jj_consume_token(38);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
        tid = jj_consume_token(OPERATOR);
        break;
      case ID:
        tid = jj_consume_token(ID);
        break;
      default:
        jj_la1[17] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                    vector.addElement( tid.image );
    }
    jj_consume_token(39);
         def.setDefinedFor(vector);
  }

  final public void tryJavaBlock(Definition def) throws ParseException {
    try {
      javablock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void javablock(Definition def) throws ParseException {
        String code;
    jj_consume_token(JAVA);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.JAVA_EQUAL, trim(code));
  }

  final public void tryCBlock(Definition def) throws ParseException {
    try {
      cblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void cblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(ANSI_C);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.C_EQUAL, trim(code));
  }

  final public void tryCppBlock(Definition def) throws ParseException {
    try {
      cppblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void cppblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(CPLUSPLUS);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.CPP_EQUAL, trim(code));
  }

  final public void tryDerivativeBlock(Definition def) throws ParseException {
    try {
      derivativeblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void derivativeblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(DERIVATIVE);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.DERIV_EQUAL, trim(code));
  }

  final public void tryMembersBlock(Definition def) throws ParseException {
    try {
      membersblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void membersblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(MEMBERS);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.MEMBERS,trim(code));
  }

  final public void tryInputsBlock(Definition def) throws ParseException {
    try {
      inputsblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void inputsblock(Definition def) throws ParseException {
        String code;
    jj_consume_token(INPUTS);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         def.setCode(Definition.INPUTS,trim(code));
  }

  final public void tryMFJavaBlock(Definition def) throws ParseException {
    try {
      mfjavablock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfjavablock(Definition def) throws ParseException {
    jj_consume_token(JAVA);
    jj_consume_token(36);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,JAVABLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,JAVABLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,JAVABLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,JAVABLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,JAVABLOCK);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(37);
  }

  final public void tryMFAnsiCBlock(Definition def) throws ParseException {
    try {
      mfansicblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfansicblock(Definition def) throws ParseException {
    jj_consume_token(ANSI_C);
    jj_consume_token(36);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,ANSICBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,ANSICBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,ANSICBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,ANSICBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,ANSICBLOCK);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(37);
  }

  final public void tryMFCppBlock(Definition def) throws ParseException {
    try {
      mfcppblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfcppblock(Definition def) throws ParseException {
    jj_consume_token(CPLUSPLUS);
    jj_consume_token(36);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,CPPBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,CPPBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,CPPBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,CPPBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,CPPBLOCK);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(37);
  }

  final public void tryMFDerivativeBlock(Definition def) throws ParseException {
    try {
      mfderivativeblock(def);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void mfderivativeblock(Definition def) throws ParseException {
    jj_consume_token(DERIVATIVE);
    jj_consume_token(36);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
      case GREATER:
      case SMALLER:
      case CENTER:
      case BASIS:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUAL:
        tryEqualBlock(def,DERIVBLOCK);
        break;
      case GREATER:
        tryGreatereqBlock(def,DERIVBLOCK);
        break;
      case SMALLER:
        trySmallereqBlock(def,DERIVBLOCK);
        break;
      case CENTER:
        tryCenterBlock(def,DERIVBLOCK);
        break;
      case BASIS:
        tryBasisBlock(def,DERIVBLOCK);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(37);
  }

  final public void tryEqualBlock(Definition def, int kind) throws ParseException {
    try {
      equalblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void equalblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(EQUAL);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_EQUAL, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_EQUAL, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_EQUAL, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_EQUAL, trim(code)); break;
         }
  }

  final public void tryGreatereqBlock(Definition def, int kind) throws ParseException {
    try {
      greatereqblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void greatereqblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(GREATER);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_GREQ, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_GREQ, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_GREQ, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_GREQ, trim(code)); break;
         }
  }

  final public void trySmallereqBlock(Definition def, int kind) throws ParseException {
    try {
      smallereqblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void smallereqblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(SMALLER);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_SMEQ, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_SMEQ, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_SMEQ, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_SMEQ, trim(code)); break;
         }
  }

  final public void tryCenterBlock(Definition def, int kind) throws ParseException {
    try {
      centerblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void centerblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(CENTER);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_CENTER, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_CENTER, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_CENTER, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_CENTER, trim(code)); break;
         }
  }

  final public void tryBasisBlock(Definition def, int kind) throws ParseException {
    try {
      basisblock(def,kind);
    } catch (ParseException e) {
                            exception(e); skipto("}");
    } catch (TokenMgrError e) {
                           exception(e); skipto("}");
    }
  }

  final public void basisblock(Definition def, int kind) throws ParseException {
         String code;
    jj_consume_token(BASIS);
    jj_consume_token(36);
    code = codeblock();
    jj_consume_token(RBRACE);
         switch(kind) {
          case JAVABLOCK:
           def.setCode(Definition.JAVA_BASIS, trim(code)); break;
          case DERIVBLOCK:
           def.setCode(Definition.DERIV_BASIS, trim(code)); break;
          case ANSICBLOCK:
           def.setCode(Definition.C_BASIS, trim(code)); break;
          case CPPBLOCK:
           def.setCode(Definition.CPP_BASIS, trim(code)); break;
         }
  }

  void parsePackageDefinition(PackageDefinition pkg) throws ParseException {
 end = false;
 while(!end) {
   try { tryDefinition(pkg); }
   catch (ParseException e) { exception(e); skipto("}"); }
   catch (TokenMgrError e) { exception(e); skipto("}"); }
  }
  }

  String codeblock() throws ParseException {
 String s = "";
 int nesting = 1;
 Token t;

 token_source.curLexState = CODEBLOCK;
 while(true) {
   t = getToken(1);
   if(t.kind == LBRACE) { nesting++; s+=t.image; }
   else if(t.kind == RBRACE) {
     nesting--;
     if( nesting == 0) break;
     else s+=t.image;
    }
   else if(t.kind == EOF) break;
   else s+=t.image;
   t = getNextToken();
  }
 token_source.curLexState = DEFAULT;
 return s;
  }

  void skipto(String st) throws ParseException {
 Token t=null;
 token_source.curLexState = CODEBLOCK;
 while(true) {
   try {
    t = getNextToken();
    if(t.kind == EOF || t.image.equals(st)) break;
   } catch (TokenMgrError e) {}
  }
 token_source.curLexState = DEFAULT;
  }

  /** Generated Token Manager. */
  public PkgParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3f01,0x4fc0c000,0x4fc0c000,0x4fc0c000,0x4fc0c000,0x4fc1c000,0x4fc1c000,0x4fc0c000,0x4fc0c000,0x5fc0c000,0x5fc0c000,0x2dc0c000,0x2dc0c000,0x0,0x0,0x80000000,0x0,0x80000000,0x3e0000,0x3e0000,0x3e0000,0x3e0000,0x3e0000,0x3e0000,0x3e0000,0x3e0000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x1c0,0x1,0x40,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public PkgParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public PkgParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PkgParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public PkgParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PkgParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public PkgParser(PkgParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(PkgParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[42];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 42; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
