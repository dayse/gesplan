/* Generated By:JavaCC: Do not edit this line. XftspConfigParser.java */
/*
 * Parser for xftsp configuration files
 */

package xfuzzy.xftsp.cfgparser;

import xfuzzy.lang.*;
import xfuzzy.xfdm.*;
import xfuzzy.xfsl.*;
import xfuzzy.xftsp.*;
import java.io.*;
import java.util.Vector;

/**
 * javaCC parser for xftsp configuration files. Creates an XftspConfig object 
 * and fills it in from the config file.
 * 
 * Comments and other general grammar works as in other xfuzzy configuration 
 * files.
 *
 * @author fedemp
 **/
public class XftspConfigParser implements XftspConfigParserConstants {

        private int error;
        private String errorMsg;
        private boolean end;

        private XftspConfig cfg;


        public XftspConfigParser() {
               this.error = 0;
               this.errorMsg = "";
               this.cfg = null;
        }

        public XftspConfig parse(File file) {
               initParse(file);
               this.cfg = new XftspConfig();
               try { tryXftspConfigFile();
               } catch(ParseException ex) {
                 return null;
               }
               if(error == 0)
                        return this.cfg;
               else
                        return null;
        }


         public String resume() {
           String eol = System.getProperty("line.separator", "\u005cn");
           String msg = this.errorMsg + this.error;
           if(this.error == 1) msg += " error."; else msg += " errors.";
           return msg+eol;
         }


         /* Private methods */

 private void initParse(File file) {
  error = 0;
  errorMsg = "";

  InputStream stream;
  try { stream = new FileInputStream(file); }
  catch (Exception e) {
   errorMsg += "Can't open file "+file.getAbsolutePath();
   error ++;
   return;
  }

  ReInit(stream);
 }


 private double[] getParams(Vector v) {
  double[] param = new double[v.size()];
  for(int i=0; i<param.length; i++)
   param[i] = Double.parseDouble((String) v.elementAt(i) );
  return param;
 }


 private void exception(ParseException e) {
  String eol = System.getProperty("line.separator", "\u005cn");
  Token t = e.currentToken.next;
  this.error ++;
  this.errorMsg += "Configuration ["+this.error+"]. ";
  this.errorMsg += "Parse error at line "+t.beginLine+" : ";
  this.errorMsg += "Encountered \u005c""+t.image+"\u005c""+" while expecting ";

  int expected[] = new int[e.expectedTokenSequences.length];
  for(int i=0; i<expected.length; i++)
   expected[i] = e.expectedTokenSequences[i][0];
  if(expected.length == 1) this.errorMsg += e.tokenImage[expected[0]]+"."+eol;
  else {
   this.errorMsg += "one of :\u005cn       "+e.tokenImage[expected[0]];
   for(int i=1; i<expected.length; i++)
    this.errorMsg += ",\u005cn       "+e.tokenImage[expected[i]];
   this.errorMsg += "."+eol;
  }
 }


 private void exception(TokenMgrError e) {
  String eol = System.getProperty("line.separator", "\u005cn");
  this.error ++;
  this.errorMsg += "Configuration ["+this.error+"]. "+e.getMessage()+eol;
 }



 private void exception(Exception e) {
  String eol = System.getProperty("line.separator", "\u005cn");
  this.error ++;
  this.errorMsg += "Configuration ["+this.error+"]. "+e.getMessage()+eol;
 }


 /* Xftsp configuration processing */

    private void processXftspSeriesName(Token tid) throws XflException {
        // if(cfg == null ) return;
        cfg.series_name = tid.image;
    }

    private void processXftspTrainingFile(Token tid) throws XflException {
        // if ( cfg == null ) return;
        String filename = tid.image.substring(1,tid.image.length()-1);
        File file = new File(filename);
        if( !file.exists() ) {
            System.out.println("Error, training file not found: " + filename);
            throw new XflException(31);
        }
        cfg.training_series_file = file;
    }

    private void processXftspTestFile(Token tid) throws XflException {
        // if ( cfg == null ) return;
        String filename = tid.image.substring(1,tid.image.length()-1);
        File file = new File(filename);
        if( !file.exists() ) {
            System.out.println("Error, test file not found: " + filename);
            throw new XflException(31);
        }
        cfg.test_series_file = file;
    }

    private void processXftspIdAlgorithm(Token tid, double[] param) throws XflException {
        // if ( xfdmcfg == null ) return;
        cfg.id_algorithm = XfdmAlgorithm.create(tid.image,param);
    }

    private void processXftspOptAlgorithm(Token tid, double[] param) throws XflException {
        // if ( cfg == null ) return;
        cfg.opt_algorithm = XfslAlgorithm.create(tid.image,param);
    }

    private void processXftspOption(Token tid, double[] param) throws XflException {
        // if(xfslcfg == null) return;
        if ( tid.image.equals("keep_pattern_files") ) {
            cfg.keep_pattern_files = true;
        }       else if ( tid.image.equals("generate_optimization_logs") ) {
            cfg.generate_optimization_logs = true;
        } else if ( tid.image.equals("tolerance") ) {
            cfg.tolerance = param[0];
        } else if ( tid.image.equals("max_exploration") ) {
            cfg.max_exploration = (int)param[0];
        } else if ( tid.image.equals("max_prediction_horizon") ) {
            cfg.max_prediction_horizon = (int)param[0];
        }
    }

    private void processXftspSelection(Token tid) throws XflException {
        String filename = tid.image.substring(1,tid.image.length()-1);
        File file = new File(filename);
        if( !file.exists() )  {
            System.out.println("Error, selection file not found: " + filename);
            throw new XflException(31);
        }
        cfg.selection_file = file;

     // TODO: load sel. file
    }

    private void processXftspNRVE(Token tid) throws XflException {
        String filename = tid.image.substring(1,tid.image.length()-1);
        File file = new File(filename);
        if( !file.exists() ) {
            System.out.println("Error, NRVE file not found: " + filename);
            throw new XflException(31);
        }
        cfg.nrve_file = file;

     // TODO: load sel. file
    }

  final public void endline() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
         end = true;
      break;
    case EOL:
      jj_consume_token(EOL);
      break;
    case CEOL:
      jj_consume_token(CEOL);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void tryDirective() throws ParseException {
    try {
      directive();
    } catch (ParseException e) {
                            exception(e); skipline();
    } catch (XflException e) {
                          exception(e); /* skipline(); */
    } catch (Exception e) {
                       exception(e); skipline();
    }
  }

  final public void directive() throws ParseException, XflException, Exception {
        Token tid, tn, tx, ty, tk;
        double[] param;
        Vector v;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case XFTSP_SERIES_NAME:
      jj_consume_token(XFTSP_SERIES_NAME);
      jj_consume_token(24);
      tid = jj_consume_token(ID);
      jj_consume_token(25);
      endline();
         processXftspSeriesName(tid);
      break;
    case XFTSP_TRAINING_FILE:
      jj_consume_token(XFTSP_TRAINING_FILE);
      jj_consume_token(24);
      tid = jj_consume_token(FILE);
      jj_consume_token(25);
      endline();
         processXftspTrainingFile(tid);
      break;
    case XFTSP_TEST_FILE:
      jj_consume_token(XFTSP_TEST_FILE);
      jj_consume_token(24);
      tid = jj_consume_token(FILE);
      jj_consume_token(25);
      endline();
         processXftspTestFile(tid);
      break;
    case XFTSP_OPTION:
      jj_consume_token(XFTSP_OPTION);
      jj_consume_token(24);
      tid = jj_consume_token(ID);
      param = listOfParamsWithComma();
      jj_consume_token(25);
      endline();
         processXftspOption(tid, param);
      break;
    case XFTSP_ID_ALGORITHM:
      jj_consume_token(XFTSP_ID_ALGORITHM);
      jj_consume_token(24);
      tid = jj_consume_token(ID);
      param = listOfParamsWithComma();
      jj_consume_token(25);
      endline();
         processXftspIdAlgorithm(tid, param);
      break;
    case XFTSP_OPT_ALGORITHM:
      jj_consume_token(XFTSP_OPT_ALGORITHM);
      jj_consume_token(24);
      tid = jj_consume_token(ID);
      param = listOfParamsWithComma();
      jj_consume_token(25);
      endline();
         processXftspOptAlgorithm(tid, param);
      break;
    case XFTSP_SELECTION:
      jj_consume_token(XFTSP_SELECTION);
      jj_consume_token(24);
      tid = jj_consume_token(FILE);
      jj_consume_token(25);
      endline();
         processXftspSelection(tid);
      break;
    case XFTSP_NRVE:
      jj_consume_token(XFTSP_NRVE);
      jj_consume_token(24);
      tid = jj_consume_token(FILE);
      jj_consume_token(25);
      endline();
         processXftspNRVE(tid);
      break;
    case 0:
    case EOL:
    case CEOL:
      endline();
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public double[] listOfParamsWithComma() throws ParseException {
        Token tn;
        Vector v = new Vector();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 26:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      jj_consume_token(26);
      tn = jj_consume_token(NUMBER);
                    v.addElement(tn.image);
    }
         {if (true) return getParams(v);}
    throw new Error("Missing return statement in function");
  }

  final public double[] listOfParams() throws ParseException {
        Token tn;
        Vector v = new Vector();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      tn = jj_consume_token(NUMBER);
                v.addElement(tn.image);
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 26:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        jj_consume_token(26);
        tn = jj_consume_token(NUMBER);
                    v.addElement(tn.image);
      }
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
         {if (true) return getParams(v);}
    throw new Error("Missing return statement in function");
  }

  void tryXftspConfigFile() throws ParseException {
 end = false;
 while(!end) {
  try { tryDirective(); }
  catch (ParseException e) { exception(e); skipline(); }
  catch (TokenMgrError e) { exception(e); end = true; }
 }
  }

  void skipline() throws ParseException {
 Token t;
 do { t = getNextToken(); }
 while(t.kind != EOF && t.kind != EOL && t.kind != CEOL);
  }

  /** Generated Token Manager. */
  public XftspConfigParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x14001,0x17fc1,0x4000000,0x4000000,0x100000,};
   }

  /** Constructor with InputStream. */
  public XftspConfigParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XftspConfigParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XftspConfigParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public XftspConfigParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XftspConfigParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public XftspConfigParser(XftspConfigParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(XftspConfigParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[27];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 5; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 27; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
